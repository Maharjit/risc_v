# IRIS LABS HARDWARE Assignment III  
**Platform:** QEMU (Raspberry Pi 2B)  
**Author:** Dipankar Deka  
**Objective:** Bare-metal UART communication, exception level handling, and memory management on emulated Raspberry Pi 2B.

---

## üß† Overview

This assignment explores low-level hardware programming using QEMU-emulated Raspberry Pi 2B. The tasks focus on:

- Direct UART0 communication in privileged mode (EL1).
- Managing exception levels to restrict peripheral access.
- Implementing a syscall mechanism for safe UART access from user space.
- (Bonus) Introducing basic virtual memory management and memory isolation between kernel and user.

---

## ‚úÖ Task 1: UART-Based Serial Output in EL1

- Developed a bare-metal program that operates in EL1 (privileged mode).
- UART0 base address and registers were referenced from the **BCM2836 SoC datasheet**.
- Implemented a custom `printf()` function using memory-mapped I/O ‚Äî no standard library dependencies.
- Sent `"Hello World"` to the QEMU serial output successfully.

---

## üîê Task 2: Restrict UART Access from EL0

- After initializing UART and system setup in EL1, the CPU was switched to **EL0 (user mode)**.
- Direct access to UART registers from EL0 was explicitly blocked.
- Any call to `printf()` from EL0 causes a **controlled exception** (undefined instruction handler catches it).
- Introduced a simple **SVC (Supervisor Call)** mechanism that allows EL0 to request UART printing via a syscall interface handled in EL1.

---

## üéØ Bonus Task: Virtual Memory and User Mode Execution

- Enabled and configured **ARMv8 MMU** for simple virtual memory support.
- Created **separate page tables** for kernel (EL1) and user (EL0) memory spaces.
- Ensured UART MMIO region is **mapped only in the kernel**.
- Mapped the user-mode program to a different virtual address region with **read/execute-only permissions**.
- User-mode `Hello World` execution is successfully isolated and controlled through syscall-based UART access.

---

## üõ†Ô∏è Build and Run Instructions

1. **Build**
   - Assembler and linker scripts are used to generate a flat binary (`kernel8.img`).
   - Compile using `aarch64-none-elf-gcc` with appropriate flags for freestanding ELF and no stdlib.

2. **Run using QEMU**
   ```bash
   qemu-system-aarch64 \
     -M raspi2 \
     -kernel kernel8.img \
     -nographic
